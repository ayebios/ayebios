<शैली गुरु>
//  Implementation of the TCG BIOS extension according to the specअगरication
//  described in specs found at
//  http://www.trustedcomputinggroup.org/resources/pc_client_work_group_specअगरic_implementation_specअगरication_क्रम_conventional_bios
//
//  Copyright (C) 2006-2011, 2014, 2015 IBM Corporation
//
//  Authors:
//      Stefan Berger <stefanb@linux.vnet.ibm.com>
//
// This file may be distributed under the terms of the GNU LGPLv3 license.

#समावेश "bregs.h" // काष्ठा bregs
#समावेश "byteorder.h" // cpu_to_*
#समावेश "config.h" // CONFIG_TCGBIOS
#समावेश "farptr.h" // MAKE_FLATPTR
#समावेश "fw/paravirt.h" // runningOnXen
#समावेश "hw/tpm_drivers.h" // tpm_drivers[]
#समावेश "output.h" // dम_लिखो
#समावेश "sha.h" // sha1, sha256, ...
#समावेश "std/acpi.h"  // RSDP_SIGNATURE, rsdt_descriptor
#समावेश "std/smbios.h" // काष्ठा smbios_entry_poपूर्णांक
#समावेश "std/tcg.h" // TCG_PC_LOGOVERFLOW
#समावेश "string.h" // checksum
#समावेश "tcgbios.h"// tpm_*, prototypes
#समावेश "util.h" // म_लिखो, get_keystroke
#समावेश "stacks.h" // रुको_thपढ़ोs, reset
#समावेश "malloc.h" // दो_स्मृति_high


/****************************************************************
 * ACPI TCPA table पूर्णांकerface
 ****************************************************************/

काष्ठा अणु
    /* length of the TCPA log buffer */
    u32           log_area_minimum_length;

    /* start address of TCPA log buffer */
    u8 *          log_area_start_address;

    /* number of log entries written */
    u32           entry_count;

    /* address to ग_लिखो next log entry to */
    u8 *          log_area_next_entry;

    /* address of last entry written (need क्रम TCG_StatusCheck) */
    u8 *          log_area_last_entry;
पूर्ण tpm_state VARLOW;

अटल पूर्णांक tpm_set_log_area(u8 *log_area_start_address,
                            u32 log_area_minimum_length)
अणु
    अगर (!log_area_start_address || !log_area_minimum_length)
        वापस -1;

    स_रखो(log_area_start_address, 0, log_area_minimum_length);
    tpm_state.log_area_start_address = log_area_start_address;
    tpm_state.log_area_minimum_length = log_area_minimum_length;
    tpm_state.log_area_next_entry = log_area_start_address;
    tpm_state.log_area_last_entry = शून्य;
    tpm_state.entry_count = 0;
    वापस 0;
पूर्ण

अटल पूर्णांक
tpm_tcpa_probe(व्योम)
अणु
    काष्ठा tcpa_descriptor_rev2 *tcpa = find_acpi_table(TCPA_SIGNATURE);
    अगर (!tcpa)
        वापस -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: TCPA: LASA = %p, LAML = %u\n",
            (u8 *)(दीर्घ)tcpa->log_area_start_address,
            tcpa->log_area_minimum_length);

    वापस tpm_set_log_area((u8*)(दीर्घ)tcpa->log_area_start_address,
                            tcpa->log_area_minimum_length);
पूर्ण

अटल पूर्णांक
tpm_tpm2_probe(व्योम)
अणु
    काष्ठा tpm2_descriptor_rev2 *tpm2 = find_acpi_table(TPM2_SIGNATURE);
    अगर (!tpm2)
        वापस -1;

    अगर (tpm2->length < 76)
        वापस -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: TPM2: LASA = %p, LAML = %u\n",
            (u8 *)(दीर्घ)tpm2->log_area_start_address,
            tpm2->log_area_minimum_length);

    वापस tpm_set_log_area((u8*)(दीर्घ)tpm2->log_area_start_address,
                            tpm2->log_area_minimum_length);
पूर्ण

/*
 * Extend the ACPI log with the given entry by copying the
 * entry data पूर्णांकo the log.
 * Input
 *  entry : The header data to use (including the variable length digest)
 *  digest_len : Length of the digest in 'entry'
 *  event : Poपूर्णांकer to the event body to be copied पूर्णांकo the log
 *  event_len : Length of 'event'
 *
 * Output:
 *  Returns an error code in हाल of faiure, 0 in हाल of success
 */
अटल पूर्णांक
tpm_log_event(काष्ठा tpm_log_header *entry, पूर्णांक digest_len
              , स्थिर व्योम *event, पूर्णांक event_len)
अणु
    dम_लिखो(DEBUG_tcg, "TCGBIOS: LASA = %p, next entry = %p\n",
            tpm_state.log_area_start_address, tpm_state.log_area_next_entry);

    अगर (tpm_state.log_area_next_entry == शून्य)
        वापस -1;

    u32 size = (माप(*entry) + digest_len
                + माप(काष्ठा tpm_log_trailer) + event_len);
    u32 logsize = (tpm_state.log_area_next_entry + size
                   - tpm_state.log_area_start_address);
    अगर (logsize > tpm_state.log_area_minimum_length) अणु
        dम_लिखो(DEBUG_tcg, "TCGBIOS: LOG OVERFLOW: size = %d\n", size);
        वापस -1;
    पूर्ण

    व्योम *dest = tpm_state.log_area_next_entry;
    स_नकल(dest, entry, माप(*entry) + digest_len);
    काष्ठा tpm_log_trailer *t = dest + माप(*entry) + digest_len;
    t->eventdatasize = event_len;
    स_नकल(t->event, event, event_len);

    tpm_state.log_area_last_entry = tpm_state.log_area_next_entry;
    tpm_state.log_area_next_entry += size;
    tpm_state.entry_count++;

    वापस 0;
पूर्ण


/****************************************************************
 * Digest क्रमmatting
 ****************************************************************/

अटल TPMVersion TPM_version;
अटल u32 tpm20_pcr_selection_size;
अटल काष्ठा tpml_pcr_selection *tpm20_pcr_selection;

// A 'struct tpm_log_entry' is a local data काष्ठाure containing a
// 'tpm_log_header' followed by space क्रम the maximum supported
// digest.  (The digest is a sha1 hash on tpm1.2 or a series of
// tpm2_digest_value काष्ठाs on tpm2.0)
काष्ठा tpm_log_entry अणु
    काष्ठा tpm_log_header hdr;
    u8 pad[माप(काष्ठा tpm2_digest_values)
           + 8 * माप(काष्ठा tpm2_digest_value)
           + SHA1_बफ_मानE + SHA256_बफ_मानE + SHA384_बफ_मानE
           + SHA512_बफ_मानE + SM3_256_बफ_मानE + SHA3_256_बफ_मानE
           + SHA3_384_बफ_मानE + SHA3_512_बफ_मानE];
पूर्ण PACKED;

अटल स्थिर काष्ठा hash_parameters अणु
    u16 hashalg;
    u8  hashalg_flag;
    u8  hash_buffersize;
    स्थिर अक्षर *name;
    व्योम (*hashfunc)(स्थिर u8 *data, u32 length, u8 *hash);
पूर्ण hash_parameters[] = अणु
    अणु
        .hashalg = TPM2_ALG_SHA1,
        .hashalg_flag = TPM2_ALG_SHA1_FLAG,
        .hash_buffersize = SHA1_बफ_मानE,
        .name = "SHA1",
        .hashfunc = sha1,
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA256,
        .hashalg_flag = TPM2_ALG_SHA256_FLAG,
        .hash_buffersize = SHA256_बफ_मानE,
        .name = "SHA256",
        .hashfunc = sha256,
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA384,
        .hashalg_flag = TPM2_ALG_SHA384_FLAG,
        .hash_buffersize = SHA384_बफ_मानE,
        .name = "SHA384",
        .hashfunc = sha384,
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA512,
        .hashalg_flag = TPM2_ALG_SHA512_FLAG,
        .hash_buffersize = SHA512_बफ_मानE,
        .name = "SHA512",
        .hashfunc = sha512,
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SM3_256,
        .hashalg_flag = TPM2_ALG_SM3_256_FLAG,
        .hash_buffersize = SM3_256_बफ_मानE,
        .name = "SM3-256",
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA3_256,
        .hashalg_flag = TPM2_ALG_SHA3_256_FLAG,
        .hash_buffersize = SHA3_256_बफ_मानE,
        .name = "SHA3-256",
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA3_384,
        .hashalg_flag = TPM2_ALG_SHA3_384_FLAG,
        .hash_buffersize = SHA3_384_बफ_मानE,
        .name = "SHA3-384",
    पूर्ण, अणु
        .hashalg = TPM2_ALG_SHA3_512,
        .hashalg_flag = TPM2_ALG_SHA3_512_FLAG,
        .hash_buffersize = SHA3_512_बफ_मानE,
        .name = "SHA3-512",
    पूर्ण
पूर्ण;

अटल पूर्णांक
tpm20_get_hash_buffersize(u16 hashAlg)
अणु
    अचिन्हित i;

    क्रम (i = 0; i < ARRAY_SIZE(hash_parameters); i++) अणु
        अगर (hash_parameters[i].hashalg == hashAlg)
            वापस hash_parameters[i].hash_buffersize;
    पूर्ण
    वापस -1;
पूर्ण

अटल u8
tpm20_hashalg_to_flag(u16 hashAlg)
अणु
    अचिन्हित i;

    क्रम (i = 0; i < ARRAY_SIZE(hash_parameters); i++) अणु
        अगर (hash_parameters[i].hashalg == hashAlg)
            वापस hash_parameters[i].hashalg_flag;
    पूर्ण
    वापस 0;
पूर्ण

अटल u16
tpm20_hashalg_flag_to_hashalg(u8 hashalg_flag)
अणु
    अचिन्हित i;

    क्रम (i = 0; i < ARRAY_SIZE(hash_parameters); i++) अणु
        अगर (hash_parameters[i].hashalg_flag == hashalg_flag)
            वापस hash_parameters[i].hashalg;
    पूर्ण
    वापस 0;
पूर्ण

अटल स्थिर अक्षर *
tpm20_hashalg_flag_to_name(u8 hashalg_flag)
अणु
    अचिन्हित i;

    क्रम (i = 0; i < ARRAY_SIZE(hash_parameters); i++) अणु
        अगर (hash_parameters[i].hashalg_flag == hashalg_flag)
            वापस hash_parameters[i].name;
    पूर्ण
    वापस शून्य;
पूर्ण

अटल व्योम tpm2_hash_data(u16 hashAlg, स्थिर u8 *data, u32 data_len, u8 *hash)
अणु
    अचिन्हित i;

    क्रम (i = 0; i < ARRAY_SIZE(hash_parameters); i++) अणु
        अगर (hash_parameters[i].hashalg == hashAlg) अणु
            अगर (hash_parameters[i].hashfunc) अणु
                hash_parameters[i].hashfunc(data, data_len, hash);
            पूर्ण अन्यथा अणु
                स_रखो(hash, 0xff, hash_parameters[i].hash_buffersize);
            पूर्ण
        पूर्ण
    पूर्ण
पूर्ण

// Add an entry at the start of the log describing digest क्रमmats
अटल पूर्णांक
tpm20_ग_लिखो_EfiSpecIdEventStruct(व्योम)
अणु
    अगर (!tpm20_pcr_selection)
        वापस -1;

    काष्ठा अणु
        काष्ठा TCG_EfiSpecIdEventStruct hdr;
        u8 pad[माप(काष्ठा tpm_log_entry) + माप(u8)];
    पूर्ण event = अणु
        .hdr.signature = "Spec ID Event03",
        .hdr.platक्रमmClass = TPM_TCPA_ACPI_CLASS_CLIENT,
        .hdr.specVersionMinor = 0,
        .hdr.specVersionMajor = 2,
        .hdr.specErrata = 2,
        .hdr.uपूर्णांकnSize = 2,
    पूर्ण;

    काष्ठा tpms_pcr_selection *sel = tpm20_pcr_selection->selections;
    व्योम *nsel, *end = (व्योम*)tpm20_pcr_selection + tpm20_pcr_selection_size;

    u32 count, numAlgs = 0;
    क्रम (count = 0; count < be32_to_cpu(tpm20_pcr_selection->count); count++) अणु
        u8 sizeOfSelect = sel->sizeOfSelect;

        nsel = (व्योम*)sel + माप(*sel) + sizeOfSelect;
        अगर (nsel > end)
            अवरोध;

        अगर (!sizeOfSelect || sel->pcrSelect[0] == 0) अणु
            sel = nsel;
            जारी;
        पूर्ण

        पूर्णांक hsize = tpm20_get_hash_buffersize(be16_to_cpu(sel->hashAlg));
        अगर (hsize < 0) अणु
            dम_लिखो(DEBUG_tcg, "TPM is using an unsupported hash: %d\n",
                    be16_to_cpu(sel->hashAlg));
            वापस -1;
        पूर्ण

        पूर्णांक event_size = दुरत्व(काष्ठा TCG_EfiSpecIdEventStruct
                                  , digestSizes[count+1]);
        अगर (event_size > माप(event) - माप(u8)) अणु
            dम_लिखो(DEBUG_tcg, "EfiSpecIdEventStruct pad too small\n");
            वापस -1;
        पूर्ण

        event.hdr.digestSizes[numAlgs].algorithmId = be16_to_cpu(sel->hashAlg);
        event.hdr.digestSizes[numAlgs].digestSize = hsize;
        numAlgs++;

        sel = nsel;
    पूर्ण

    अगर (sel != end) अणु
        dम_लिखो(DEBUG_tcg, "Malformed pcr selection structure fron TPM\n");
        वापस -1;
    पूर्ण

    event.hdr.numberOfAlgorithms = numAlgs;
    पूर्णांक event_size = दुरत्व(काष्ठा TCG_EfiSpecIdEventStruct
                              , digestSizes[numAlgs]);
    u8 *venकरोrInfoSize = (व्योम*)&event + event_size;
    *venकरोrInfoSize = 0;
    event_size += माप(*venकरोrInfoSize);

    काष्ठा tpm_log_entry le = अणु
        .hdr.eventtype = EV_NO_ACTION,
    पूर्ण;
    वापस tpm_log_event(&le.hdr, SHA1_बफ_मानE, &event, event_size);
पूर्ण

/*
 * Build the TPM2 tpm2_digest_values data काष्ठाure from the given hash.
 * Follow the PCR bank configuration of the TPM and ग_लिखो the same hash
 * in either truncated or zero-padded क्रमm in the areas of all the other
 * hashes. For example, ग_लिखो the sha1 hash in the area of the sha256
 * hash and fill the reमुख्यing bytes with zeros. Or truncate the sha256
 * hash when writing it in the area of the sha1 hash.
 *
 * le: the log entry to build the digest in
 * hashdata: the data to hash
 * hashdata_len: the length of the hashdata
 * bigEndian: whether to build in big endian क्रमmat क्रम the TPM or
 *            little endian क्रम the log
 *
 * Returns the digest size; -1 on fatal error
 */
अटल पूर्णांक
tpm20_build_digest(काष्ठा tpm_log_entry *le,
                   स्थिर u8 *hashdata, u32 hashdata_len, पूर्णांक bigEndian)
अणु
    अगर (!tpm20_pcr_selection)
        वापस -1;

    काष्ठा tpms_pcr_selection *sel = tpm20_pcr_selection->selections;
    व्योम *nsel, *end = (व्योम*)tpm20_pcr_selection + tpm20_pcr_selection_size;
    व्योम *dest = le->hdr.digest + माप(काष्ठा tpm2_digest_values);

    u32 count, numAlgs = 0;
    क्रम (count = 0; count < be32_to_cpu(tpm20_pcr_selection->count); count++) अणु
        u8 sizeOfSelect = sel->sizeOfSelect;

        nsel = (व्योम*)sel + माप(*sel) + sizeOfSelect;
        अगर (nsel > end)
            अवरोध;

        /* PCR 0-7 unused? -- skip */
        अगर (!sizeOfSelect || sel->pcrSelect[0] == 0) अणु
            sel = nsel;
            जारी;
        पूर्ण

        पूर्णांक hsize = tpm20_get_hash_buffersize(be16_to_cpu(sel->hashAlg));
        अगर (hsize < 0) अणु
            dम_लिखो(DEBUG_tcg, "TPM is using an unsupported hash: %d\n",
                    be16_to_cpu(sel->hashAlg));
            वापस -1;
        पूर्ण

        /* buffer size sanity check beक्रमe writing */
        काष्ठा tpm2_digest_value *v = dest;
        अगर (dest + माप(*v) + hsize > (व्योम*)le + माप(*le)) अणु
            dम_लिखो(DEBUG_tcg, "tpm_log_entry is too small\n");
            वापस -1;
        पूर्ण

        अगर (bigEndian)
            v->hashAlg = sel->hashAlg;
        अन्यथा
            v->hashAlg = be16_to_cpu(sel->hashAlg);

        tpm2_hash_data(be16_to_cpu(sel->hashAlg), hashdata, hashdata_len,
                       v->hash);

        dest += माप(*v) + hsize;
        sel = nsel;

        numAlgs++;
    पूर्ण

    अगर (sel != end) अणु
        dम_लिखो(DEBUG_tcg, "Malformed pcr selection structure fron TPM\n");
        वापस -1;
    पूर्ण

    काष्ठा tpm2_digest_values *v = (व्योम*)le->hdr.digest;
    अगर (bigEndian)
        v->count = cpu_to_be32(numAlgs);
    अन्यथा
        v->count = numAlgs;

    वापस dest - (व्योम*)le->hdr.digest;
पूर्ण

अटल पूर्णांक
tpm12_build_digest(काष्ठा tpm_log_entry *le,
                   स्थिर u8 *hashdata, u32 hashdata_len)
अणु
    sha1(hashdata, hashdata_len, le->hdr.digest);
    वापस SHA1_बफ_मानE;
पूर्ण

अटल पूर्णांक
tpm12_build_digest_direct(काष्ठा tpm_log_entry *le, स्थिर u8 *sha1)
अणु
    // On TPM 1.2 the digest contains just the SHA1 hash
    स_नकल(le->hdr.digest, sha1, SHA1_बफ_मानE);
    वापस SHA1_बफ_मानE;
पूर्ण

अटल पूर्णांक
tpm_build_digest(काष्ठा tpm_log_entry *le, स्थिर u8 *hashdata, u32 hashdata_len
                 , पूर्णांक bigEndian)
अणु
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        वापस tpm12_build_digest(le, hashdata, hashdata_len);
    हाल TPM_VERSION_2:
        वापस tpm20_build_digest(le, hashdata, hashdata_len, bigEndian);
    पूर्ण
    वापस -1;
पूर्ण


/****************************************************************
 * TPM hardware command wrappers
 ****************************************************************/

// Helper function क्रम sending tpm commands that take a single
// optional parameter (0, 1, or 2 bytes) and have no special response.
अटल पूर्णांक
tpm_simple_cmd(u8 locty, u32 ordinal
               , पूर्णांक param_size, u16 param, क्रमागत tpmDurationType to_t)
अणु
    काष्ठा अणु
        काष्ठा tpm_req_header trqh;
        u16 param;
    पूर्ण PACKED req = अणु
        .trqh.totlen = cpu_to_be32(माप(req.trqh) + param_size),
        .trqh.ordinal = cpu_to_be32(ordinal),
        .param = param_size == 2 ? cpu_to_be16(param) : param,
    पूर्ण;
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        req.trqh.tag = cpu_to_be16(TPM_TAG_RQU_CMD);
        अवरोध;
    हाल TPM_VERSION_2:
        req.trqh.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS);
        अवरोध;
    पूर्ण

    u8 obuffer[64];
    काष्ठा tpm_rsp_header *trsh = (व्योम*)obuffer;
    u32 obuffer_len = माप(obuffer);
    स_रखो(obuffer, 0x0, माप(obuffer));

    पूर्णांक ret = tpmhw_transmit(locty, &req.trqh, obuffer, &obuffer_len, to_t);
    ret = ret ? -1 : be32_to_cpu(trsh->errcode);
    dम_लिखो(DEBUG_tcg, "Return from tpm_simple_cmd(%x, %x) = %x\n",
            ordinal, param, ret);
    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_अ_लोapability(u32 capability, u32 property, u32 count,
                    काष्ठा tpm_rsp_header *rsp, u32 rsize)
अणु
    काष्ठा tpm2_req_अ_लोapability trg = अणु
        .hdr.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS),
        .hdr.totlen = cpu_to_be32(माप(trg)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_GetCapability),
        .capability = cpu_to_be32(capability),
        .property = cpu_to_be32(property),
        .propertycount = cpu_to_be32(count),
    पूर्ण;

    u32 resp_size = rsize;
    पूर्णांक ret = tpmhw_transmit(0, &trg.hdr, rsp, &resp_size,
                             TPM_DURATION_TYPE_SHORT);
    ret = (ret ||
           rsize < be32_to_cpu(rsp->totlen)) ? -1 : be32_to_cpu(rsp->errcode);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_GetCapability = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_get_pcrbanks(व्योम)
अणु
    u8 buffer[128];
    काष्ठा tpm2_res_अ_लोapability *trg =
      (काष्ठा tpm2_res_अ_लोapability *)&buffer;

    पूर्णांक ret = tpm20_अ_लोapability(TPM2_CAP_PCRS, 0, 8, &trg->hdr,
                                  माप(buffer));
    अगर (ret)
        वापस ret;

    /* defend against (broken) TPM sending packets that are too लघु */
    u32 resplen = be32_to_cpu(trg->hdr.totlen);
    अगर (resplen <= दुरत्व(काष्ठा tpm2_res_अ_लोapability, data))
        वापस -1;

    u32 size = resplen - दुरत्व(काष्ठा tpm2_res_अ_लोapability, data);
    /* we need a valid tpml_pcr_selection up to and including sizeOfSelect */
    अगर (size < दुरत्व(काष्ठा tpml_pcr_selection, selections) +
               दुरत्व(काष्ठा tpms_pcr_selection, pcrSelect))
        वापस -1;

    tpm20_pcr_selection = दो_स्मृति_high(size);
    अगर (tpm20_pcr_selection) अणु
        स_नकल(tpm20_pcr_selection, &trg->data, size);
        tpm20_pcr_selection_size = size;
    पूर्ण अन्यथा अणु
        warn_noalloc();
        ret = -1;
    पूर्ण

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_get_suppt_pcrbanks(u8 *suppt_pcrbanks, u8 *active_pcrbanks)
अणु
    *suppt_pcrbanks = 0;
    *active_pcrbanks = 0;

    अगर (!tpm20_pcr_selection)
        वापस -1;

    काष्ठा tpms_pcr_selection *sel = tpm20_pcr_selection->selections;
    व्योम *end = (व्योम*)tpm20_pcr_selection + tpm20_pcr_selection_size;

    जबतक (1) अणु
        u8 sizeOfSelect = sel->sizeOfSelect;
        व्योम *nsel = (व्योम*)sel + माप(*sel) + sizeOfSelect;
        अगर (nsel > end)
            वापस 0;

        u16 hashalg = be16_to_cpu(sel->hashAlg);
        u8 hashalg_flag = tpm20_hashalg_to_flag(hashalg);

        *suppt_pcrbanks |= hashalg_flag;

        अचिन्हित i;
        क्रम (i = 0; i < sizeOfSelect; i++) अणु
            अगर (sel->pcrSelect[i]) अणु
                *active_pcrbanks |= hashalg_flag;
                अवरोध;
            पूर्ण
        पूर्ण

        sel = nsel;
    पूर्ण
पूर्ण

अटल पूर्णांक
tpm20_set_pcrbanks(u32 active_banks)
अणु
    काष्ठा tpm2_req_pcr_allocate trpa = अणु
        .hdr.tag     = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_PCR_Allocate),
        .authhandle = cpu_to_be32(TPM2_RH_PLATFORM),
        .authblocksize = cpu_to_be32(माप(trpa.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
    पूर्ण;
    काष्ठा tpms_pcr_selection3 अणु
        u16 hashAlg;
        u8 sizeOfSelect;
        u8 pcrSelect[3];
    पूर्ण tps[ARRAY_SIZE(trpa.tpms_pcr_selections)];
    पूर्णांक i = 0;
    u8 hashalg_flag = TPM2_ALG_SHA1_FLAG;
    u8 करोntcare, suppt_banks;

    tpm20_get_suppt_pcrbanks(&suppt_banks, &करोntcare);

    जबतक (hashalg_flag) अणु
        अगर ((hashalg_flag & suppt_banks)) अणु
            u16 hashalg = tpm20_hashalg_flag_to_hashalg(hashalg_flag);

            अगर (hashalg) अणु
                u8 mask = 0;
                tps[i].hashAlg = cpu_to_be16(hashalg);
                tps[i].sizeOfSelect = 3;

                अगर (active_banks & hashalg_flag)
                    mask = 0xff;

                tps[i].pcrSelect[0] = mask;
                tps[i].pcrSelect[1] = mask;
                tps[i].pcrSelect[2] = mask;
                i++;
            पूर्ण
        पूर्ण
        hashalg_flag <<= 1;
    पूर्ण

    trpa.count = cpu_to_be32(i);
    स_नकल(trpa.tpms_pcr_selections, tps, i * माप(tps[0]));
    trpa.hdr.totlen = cpu_to_be32(दुरत्व(काष्ठा tpm2_req_pcr_allocate,
                                           tpms_pcr_selections) +
                                  i * माप(tps[0]));

    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);

    पूर्णांक ret = tpmhw_transmit(0, &trpa.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_SHORT);
    ret = ret ? -1 : be32_to_cpu(rsp.errcode);

    वापस ret;
पूर्ण

अटल पूर्णांक tpm20_activate_pcrbanks(u32 active_banks)
अणु
    पूर्णांक ret = tpm20_set_pcrbanks(active_banks);
    अगर (!ret)
        ret = tpm_simple_cmd(0, TPM2_CC_Shutकरोwn,
                             2, TPM2_SU_CLEAR, TPM_DURATION_TYPE_SHORT);
    अगर (!ret)
        reset();
    वापस ret;
पूर्ण

अटल पूर्णांक
tpm12_get_capability(u32 cap, u32 subcap, काष्ठा tpm_rsp_header *rsp, u32 rsize)
अणु
    काष्ठा tpm_req_अ_लोap trgc = अणु
        .hdr.tag = cpu_to_be16(TPM_TAG_RQU_CMD),
        .hdr.totlen = cpu_to_be32(माप(trgc)),
        .hdr.ordinal = cpu_to_be32(TPM_ORD_GetCapability),
        .capArea = cpu_to_be32(cap),
        .subCapSize = cpu_to_be32(माप(trgc.subCap)),
        .subCap = cpu_to_be32(subcap)
    पूर्ण;
    u32 resp_size = rsize;
    पूर्णांक ret = tpmhw_transmit(0, &trgc.hdr, rsp, &resp_size,
                             TPM_DURATION_TYPE_SHORT);
    ret = (ret || resp_size != rsize) ? -1 : be32_to_cpu(rsp->errcode);
    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return code from TPM_GetCapability(%d, %d)"
            " = %x\n", cap, subcap, ret);
    वापस ret;
पूर्ण

अटल पूर्णांक
tpm12_पढ़ो_permanent_flags(अक्षर *buf, पूर्णांक buf_len)
अणु
    स_रखो(buf, 0, buf_len);

    काष्ठा tpm_res_अ_लोap_perm_flags pf;
    पूर्णांक ret = tpm12_get_capability(TPM_CAP_FLAG, TPM_CAP_FLAG_PERMANENT
                                   , &pf.hdr, माप(pf));
    अगर (ret)
        वापस -1;

    स_नकल(buf, &pf.perm_flags, buf_len);

    वापस 0;
पूर्ण

अटल पूर्णांक
tpm12_determine_समयouts(व्योम)
अणु
    काष्ठा tpm_res_अ_लोap_समयouts समयouts;
    पूर्णांक ret = tpm12_get_capability(TPM_CAP_PROPERTY, TPM_CAP_PROP_TIS_TIMEOUT
                                   , &समयouts.hdr, माप(समयouts));
    अगर (ret)
        वापस ret;

    काष्ठा tpm_res_अ_लोap_durations durations;
    ret = tpm12_get_capability(TPM_CAP_PROPERTY, TPM_CAP_PROP_DURATION
                               , &durations.hdr, माप(durations));
    अगर (ret)
        वापस ret;

    पूर्णांक i;
    क्रम (i = 0; i < 3; i++)
        durations.durations[i] = be32_to_cpu(durations.durations[i]);

    क्रम (i = 0; i < 4; i++)
        समयouts.समयouts[i] = be32_to_cpu(समयouts.समयouts[i]);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: timeouts: %u %u %u %u\n",
            समयouts.समयouts[0],
            समयouts.समयouts[1],
            समयouts.समयouts[2],
            समयouts.समयouts[3]);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: durations: %u %u %u\n",
            durations.durations[0],
            durations.durations[1],
            durations.durations[2]);

    tpmhw_set_समयouts(समयouts.समयouts, durations.durations);

    वापस 0;
पूर्ण

अटल व्योम
tpm20_set_समयouts(व्योम)
अणु
    u32 durations[3] = अणु
        TPM2_DEFAULT_DURATION_SHORT,
        TPM2_DEFAULT_DURATION_MEDIUM,
        TPM2_DEFAULT_DURATION_LONG,
    पूर्ण;
    u32 समयouts[4] = अणु
        TIS2_DEFAULT_TIMEOUT_A,
        TIS2_DEFAULT_TIMEOUT_B,
        TIS2_DEFAULT_TIMEOUT_C,
        TIS2_DEFAULT_TIMEOUT_D,
    पूर्ण;

    tpmhw_set_समयouts(समयouts, durations);
पूर्ण

अटल पूर्णांक
tpm12_extend(काष्ठा tpm_log_entry *le, पूर्णांक digest_len)
अणु
    काष्ठा tpm_req_extend tre = अणु
        .hdr.tag     = cpu_to_be16(TPM_TAG_RQU_CMD),
        .hdr.totlen  = cpu_to_be32(माप(tre)),
        .hdr.ordinal = cpu_to_be32(TPM_ORD_Extend),
        .pcrindex    = cpu_to_be32(le->hdr.pcrindex),
    पूर्ण;
    स_नकल(tre.digest, le->hdr.digest, माप(tre.digest));

    काष्ठा tpm_rsp_extend rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &tre.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_SHORT);
    अगर (ret || resp_length != माप(rsp) || rsp.hdr.errcode)
        वापस -1;

    वापस 0;
पूर्ण

अटल पूर्णांक tpm20_extend(काष्ठा tpm_log_entry *le, पूर्णांक digest_len)
अणु
    काष्ठा tpm2_req_extend पंचांगp_tre = अणु
        .hdr.tag     = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.totlen  = cpu_to_be32(0),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_PCR_Extend),
        .pcrindex    = cpu_to_be32(le->hdr.pcrindex),
        .authblocksize = cpu_to_be32(माप(पंचांगp_tre.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
    पूर्ण;
    u8 buffer[माप(पंचांगp_tre) + माप(le->pad)];
    काष्ठा tpm2_req_extend *tre = (काष्ठा tpm2_req_extend *)buffer;

    स_नकल(tre, &पंचांगp_tre, माप(पंचांगp_tre));
    स_नकल(&tre->digest[0], le->hdr.digest, digest_len);

    tre->hdr.totlen = cpu_to_be32(माप(पंचांगp_tre) + digest_len);

    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &tre->hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_SHORT);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        वापस -1;

    वापस 0;
पूर्ण

अटल पूर्णांक
tpm_extend(काष्ठा tpm_log_entry *le, पूर्णांक digest_len)
अणु
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        वापस tpm12_extend(le, digest_len);
    हाल TPM_VERSION_2:
        वापस tpm20_extend(le, digest_len);
    पूर्ण
    वापस -1;
पूर्ण

अटल पूर्णांक
tpm20_stirअक्रमom(व्योम)
अणु
    काष्ठा tpm2_req_stirअक्रमom stir = अणु
        .hdr.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS),
        .hdr.totlen = cpu_to_be32(माप(stir)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_StirRanकरोm),
        .size = cpu_to_be16(माप(stir.stir)),
        .stir = rdtscll(),
    पूर्ण;
    /* set more bits to stir with */
    stir.stir += swab64(rdtscll());

    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &stir.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_SHORT);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        ret = -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_StirRandom = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_getअक्रमom(u8 *buf, u16 buf_len)
अणु
    काष्ठा tpm2_res_getअक्रमom rsp;

    अगर (buf_len > माप(rsp.rnd.buffer))
        वापस -1;

    काष्ठा tpm2_req_getअक्रमom trgr = अणु
        .hdr.tag = cpu_to_be16(TPM2_ST_NO_SESSIONS),
        .hdr.totlen = cpu_to_be32(माप(trgr)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_GetRanकरोm),
        .bytesRequested = cpu_to_be16(buf_len),
    पूर्ण;
    u32 resp_length = माप(rsp);

    पूर्णांक ret = tpmhw_transmit(0, &trgr.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_MEDIUM);
    अगर (ret || resp_length != माप(rsp) || rsp.hdr.errcode)
        ret = -1;
    अन्यथा
        स_नकल(buf, rsp.rnd.buffer, buf_len);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_GetRandom = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_hierarchycontrol(u32 hierarchy, u8 state)
अणु
    /* we will try to deactivate the TPM now - ignoring all errors */
    काष्ठा tpm2_req_hierarchycontrol trh = अणु
        .hdr.tag = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.totlen = cpu_to_be32(माप(trh)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_HierarchyControl),
        .authhandle = cpu_to_be32(TPM2_RH_PLATFORM),
        .authblocksize = cpu_to_be32(माप(trh.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
        .enable = cpu_to_be32(hierarchy),
        .state = state,
    पूर्ण;
    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &trh.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_MEDIUM);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        ret = -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_HierarchyControl = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_hierarchychangeauth(u8 auth[20])
अणु
    काष्ठा tpm2_req_hierarchychangeauth trhca = अणु
        .hdr.tag = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.totlen = cpu_to_be32(माप(trhca)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_HierarchyChangeAuth),
        .authhandle = cpu_to_be32(TPM2_RH_PLATFORM),
        .authblocksize = cpu_to_be32(माप(trhca.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
        .newAuth = अणु
            .size = cpu_to_be16(माप(trhca.newAuth.buffer)),
        पूर्ण,
    पूर्ण;
    स_नकल(trhca.newAuth.buffer, auth, माप(trhca.newAuth.buffer));

    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &trhca.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_MEDIUM);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        ret = -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_HierarchyChangeAuth = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण


/****************************************************************
 * Setup and Measurements
 ****************************************************************/

अटल पूर्णांक TPM_has_physical_presence;
u8 TPM_working VARLOW;

अटल पूर्णांक
tpm_is_working(व्योम)
अणु
    वापस CONFIG_TCGBIOS && TPM_working;
पूर्ण

अटल व्योम
tpm_set_failure(व्योम)
अणु
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        /*
         * We will try to deactivate the TPM now - ignoring all errors
         * Physical presence is निश्चितed.
         */

        tpm_simple_cmd(0, TPM_ORD_SetTempDeactivated,
                       0, 0, TPM_DURATION_TYPE_SHORT);
        अवरोध;
    हाल TPM_VERSION_2:
        tpm20_hierarchycontrol(TPM2_RH_ENDORSEMENT, TPM2_NO);
        tpm20_hierarchycontrol(TPM2_RH_OWNER, TPM2_NO);
        अवरोध;
    पूर्ण

    TPM_working = 0;
पूर्ण

/*
 * Add a measurement to the log; the data at data_seg:data/length are
 * appended to the TCG_PCClientPCREventStruct
 *
 * Input parameters:
 *  pcrindex   : which PCR to extend
 *  event_type : type of event; specs section on 'Event Types'
 *  event       : poपूर्णांकer to info (e.g., string) to be added to log as-is
 *  event_length: length of the event
 *  hashdata    : poपूर्णांकer to the data to be hashed
 *  hashdata_length: length of the data to be hashed
 */
अटल व्योम
tpm_add_measurement_to_log(u32 pcrindex, u32 event_type,
                           स्थिर अक्षर *event, u32 event_length,
                           स्थिर u8 *hashdata, u32 hashdata_length)
अणु
    अगर (!tpm_is_working())
        वापस;

    काष्ठा tpm_log_entry le = अणु
        .hdr.pcrindex = pcrindex,
        .hdr.eventtype = event_type,
    पूर्ण;
    पूर्णांक digest_len = tpm_build_digest(&le, hashdata, hashdata_length, 1);
    अगर (digest_len < 0)
        वापस;
    पूर्णांक ret = tpm_extend(&le, digest_len);
    अगर (ret) अणु
        tpm_set_failure();
        वापस;
    पूर्ण
    tpm_build_digest(&le, hashdata, hashdata_length, 0);
    tpm_log_event(&le.hdr, digest_len, event, event_length);
पूर्ण

// Add an EV_ACTION measurement to the list of measurements
अटल व्योम
tpm_add_action(u32 pcrIndex, स्थिर अक्षर *string)
अणु
    u32 len = म_माप(string);
    tpm_add_measurement_to_log(pcrIndex, EV_ACTION,
                               string, len, (u8 *)string, len);
पूर्ण

/*
 * Add event separators क्रम PCRs 0 to 7; specs on 'Measuring Boot Events'
 */
अटल व्योम
tpm_add_event_separators(व्योम)
अणु
    अटल स्थिर u8 evt_separator[] = अणु0xff,0xff,0xff,0xffपूर्ण;
    u32 pcrIndex;
    क्रम (pcrIndex = 0; pcrIndex <= 7; pcrIndex++)
        tpm_add_measurement_to_log(pcrIndex, EV_SEPARATOR,
                                   (स्थिर अक्षर *)evt_separator,
                                   माप(evt_separator),
                                   evt_separator,
                                   माप(evt_separator));
पूर्ण

अटल व्योम
tpm_smbios_measure(व्योम)
अणु
    काष्ठा pcctes pcctes = अणु
        .eventid = 1,
        .eventdatasize = SHA1_बफ_मानE,
    पूर्ण;
    काष्ठा smbios_entry_poपूर्णांक *sep = SMBiosAddr;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: SMBIOS at %p\n", sep);

    अगर (!sep)
        वापस;

    sha1((स्थिर u8 *)sep->काष्ठाure_table_address,
         sep->काष्ठाure_table_length, pcctes.digest);
    tpm_add_measurement_to_log(1,
                               EV_EVENT_TAG,
                               (स्थिर अक्षर *)&pcctes, माप(pcctes),
                               (u8 *)&pcctes, माप(pcctes));
पूर्ण

अटल पूर्णांक
tpm12_निश्चित_physical_presence(व्योम)
अणु
    पूर्णांक ret = tpm_simple_cmd(0, TPM_ORD_PhysicalPresence,
                             2, TPM_PP_PRESENT, TPM_DURATION_TYPE_SHORT);
    अगर (!ret)
        वापस 0;

    काष्ठा tpm_permanent_flags pf;
    ret = tpm12_पढ़ो_permanent_flags((अक्षर *)&pf, माप(pf));
    अगर (ret)
        वापस -1;

    /* check अगर hardware physical presence is supported */
    अगर (pf.flags[PERM_FLAG_IDX_PHYSICAL_PRESENCE_HW_ENABLE]) अणु
        /* HW phys. presence may not be निश्चितed... */
        वापस 0;
    पूर्ण

    अगर (!pf.flags[PERM_FLAG_IDX_PHYSICAL_PRESENCE_LIFETIME_LOCK]
        && !pf.flags[PERM_FLAG_IDX_PHYSICAL_PRESENCE_CMD_ENABLE]) अणु
        tpm_simple_cmd(0, TPM_ORD_PhysicalPresence,
                       2, TPM_PP_CMD_ENABLE, TPM_DURATION_TYPE_SHORT);

        वापस tpm_simple_cmd(0, TPM_ORD_PhysicalPresence,
                              2, TPM_PP_PRESENT, TPM_DURATION_TYPE_SHORT);
    पूर्ण
    वापस -1;
पूर्ण

अटल पूर्णांक
tpm12_startup(व्योम)
अणु
    dम_लिखो(DEBUG_tcg, "TCGBIOS: Starting with TPM_Startup(ST_CLEAR)\n");
    पूर्णांक ret = tpm_simple_cmd(0, TPM_ORD_Startup,
                             2, TPM_ST_CLEAR, TPM_DURATION_TYPE_SHORT);
    अगर (CONFIG_COREBOOT && ret == TPM_INVALID_POSTINIT)
        /* with other firmware on the प्रणाली the TPM may alपढ़ोy have been
         * initialized
         */
        ret = 0;
    अगर (ret)
        जाओ err_निकास;

    /* निश्चितion of physical presence is only possible after startup */
    ret = tpm12_निश्चित_physical_presence();
    अगर (!ret)
        TPM_has_physical_presence = 1;

    ret = tpm12_determine_समयouts();
    अगर (ret)
        जाओ err_निकास;

    ret = tpm_simple_cmd(0, TPM_ORD_SelfTestFull,
                         0, 0, TPM_DURATION_TYPE_LONG);
    अगर (ret)
        जाओ err_निकास;

    ret = tpm_simple_cmd(3, TSC_ORD_ResetEstablishmentBit,
                         0, 0, TPM_DURATION_TYPE_SHORT);
    अगर (ret && ret != TPM_BAD_LOCALITY)
        जाओ err_निकास;

    वापस 0;

err_निकास:
    dम_लिखो(DEBUG_tcg, "TCGBIOS: TPM malfunctioning (line %d).\n", __LINE__);

    tpm_set_failure();
    वापस -1;
पूर्ण

अटल पूर्णांक
tpm20_startup(व्योम)
अणु
    tpm20_set_समयouts();

    पूर्णांक ret = tpm_simple_cmd(0, TPM2_CC_Startup,
                             2, TPM2_SU_CLEAR, TPM_DURATION_TYPE_SHORT);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_Startup(SU_CLEAR) = 0x%08x\n",
            ret);

    अगर (CONFIG_COREBOOT && ret == TPM2_RC_INITIALIZE)
        /* with other firmware on the प्रणाली the TPM may alपढ़ोy have been
         * initialized
         */
        ret = 0;

    अगर (ret)
        जाओ err_निकास;

    ret = tpm_simple_cmd(0, TPM2_CC_SelfTest,
                         1, TPM2_YES, TPM_DURATION_TYPE_LONG);

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_SelfTest = 0x%08x\n",
            ret);

    अगर (ret)
        जाओ err_निकास;

    ret = tpm20_get_pcrbanks();
    अगर (ret)
        जाओ err_निकास;

    ret = tpm20_ग_लिखो_EfiSpecIdEventStruct();
    अगर (ret)
        जाओ err_निकास;

    वापस 0;

err_निकास:
    dम_लिखो(DEBUG_tcg, "TCGBIOS: TPM malfunctioning (line %d).\n", __LINE__);

    tpm_set_failure();
    वापस -1;
पूर्ण

अटल पूर्णांक
tpm_startup(व्योम)
अणु
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        वापस tpm12_startup();
    हाल TPM_VERSION_2:
        वापस tpm20_startup();
    पूर्ण
    वापस -1;
पूर्ण

व्योम
tpm_setup(व्योम)
अणु
    अगर (!CONFIG_TCGBIOS)
        वापस;

    पूर्णांक ret = tpm_tpm2_probe();
    अगर (ret) अणु
        ret = tpm_tcpa_probe();
        अगर (ret)
            वापस;
    पूर्ण

    TPM_version = tpmhw_probe();
    अगर (TPM_version == TPM_VERSION_NONE)
        वापस;

    dम_लिखो(DEBUG_tcg,
            "TCGBIOS: Detected a TPM %s.\n",
             (TPM_version == TPM_VERSION_1_2) ? "1.2" : "2");

    TPM_working = 1;

    अगर (runningOnXen())
        वापस;

    ret = tpm_startup();
    अगर (ret)
        वापस;

    tpm_smbios_measure();
    tpm_add_action(2, "Start Option ROM Scan");
पूर्ण

अटल व्योम
tpm20_prepboot(व्योम)
अणु
    पूर्णांक ret = tpm20_stirअक्रमom();
    अगर (ret)
         जाओ err_निकास;

    u8 auth[20];
    ret = tpm20_getअक्रमom(&auth[0], माप(auth));
    अगर (ret)
        जाओ err_निकास;

    ret = tpm20_hierarchychangeauth(auth);
    अगर (ret)
        जाओ err_निकास;

    वापस;

err_निकास:
    dम_लिखो(DEBUG_tcg, "TCGBIOS: TPM malfunctioning (line %d).\n", __LINE__);

    tpm_set_failure();
पूर्ण

व्योम
tpm_prepboot(व्योम)
अणु
    अगर (!CONFIG_TCGBIOS)
        वापस;

    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        अगर (TPM_has_physical_presence)
            tpm_simple_cmd(0, TPM_ORD_PhysicalPresence,
                           2, TPM_PP_NOT_PRESENT_LOCK, TPM_DURATION_TYPE_SHORT);
        अवरोध;
    हाल TPM_VERSION_2:
        tpm20_prepboot();
        अवरोध;
    पूर्ण

    tpm_add_action(4, "Calling INT 19h");
    tpm_add_event_separators();
पूर्ण

/*
 * Add measurement to the log about an option rom
 */
व्योम
tpm_option_rom(स्थिर व्योम *addr, u32 len)
अणु
    अगर (!tpm_is_working())
        वापस;

    काष्ठा pcctes_romex pcctes = अणु
        .eventid = 7,
        .eventdatasize = माप(u16) + माप(u16) + SHA1_बफ_मानE,
    पूर्ण;
    sha1((स्थिर u8 *)addr, len, pcctes.digest);
    tpm_add_measurement_to_log(2,
                               EV_EVENT_TAG,
                               (स्थिर अक्षर *)&pcctes, माप(pcctes),
                               (u8 *)&pcctes, माप(pcctes));
पूर्ण

व्योम
tpm_add_bcv(u32 bootdrv, स्थिर u8 *addr, u32 length)
अणु
    अगर (!tpm_is_working())
        वापस;

    अगर (length < 0x200)
        वापस;

    स्थिर अक्षर *string = "Booting BCV device 00h (Floppy)";
    अगर (bootdrv == 0x80)
        string = "Booting BCV device 80h (HDD)";
    tpm_add_action(4, string);

    /* specs: see section 'Hard Disk Device or Hard Disk-Like Devices' */
    /* equivalent to: dd अगर=/dev/hda ibs=1 count=440 | sha1sum */
    string = "MBR";
    tpm_add_measurement_to_log(4, EV_IPL,
                               string, म_माप(string),
                               addr, 0x1b8);

    /* equivalent to: dd अगर=/dev/hda ibs=1 count=72 skip=440 | sha1sum */
    string = "MBR PARTITION_TABLE";
    tpm_add_measurement_to_log(5, EV_IPL_PARTITION_DATA,
                               string, म_माप(string),
                               addr + 0x1b8, 0x48);
पूर्ण

व्योम
tpm_add_cdrom(u32 bootdrv, स्थिर u8 *addr, u32 length)
अणु
    अगर (!tpm_is_working())
        वापस;

    tpm_add_action(4, "Booting from CD ROM device");

    /* specs: see section 'El Torito' */
    स्थिर अक्षर *string = "EL TORITO IPL";
    tpm_add_measurement_to_log(4, EV_IPL,
                               string, म_माप(string),
                               addr, length);
पूर्ण

व्योम
tpm_add_cdrom_catalog(स्थिर u8 *addr, u32 length)
अणु
    अगर (!tpm_is_working())
        वापस;

    tpm_add_action(4, "Booting from CD ROM device");

    /* specs: see section 'El Torito' */
    स्थिर अक्षर *string = "BOOT CATALOG";
    tpm_add_measurement_to_log(5, EV_IPL_PARTITION_DATA,
                               string, म_माप(string),
                               addr, length);
पूर्ण

व्योम
tpm_s3_resume(व्योम)
अणु
    अगर (!tpm_is_working())
        वापस;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Resuming with TPM_Startup(ST_STATE)\n");

    पूर्णांक ret = -1;

    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        ret = tpm_simple_cmd(0, TPM_ORD_Startup,
                             2, TPM_ST_STATE, TPM_DURATION_TYPE_SHORT);
        अवरोध;
    हाल TPM_VERSION_2:
        ret = tpm_simple_cmd(0, TPM2_CC_Startup,
                             2, TPM2_SU_STATE, TPM_DURATION_TYPE_SHORT);

        dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_Startup(SU_STATE) = 0x%08x\n",
                ret);

        अगर (ret)
            जाओ err_निकास;


        ret = tpm_simple_cmd(0, TPM2_CC_SelfTest,
                             1, TPM2_YES, TPM_DURATION_TYPE_LONG);

        dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_SelfTest() = 0x%08x\n",
                ret);

        अवरोध;
    पूर्ण

    अगर (ret)
        जाओ err_निकास;

    वापस;

err_निकास:
    dम_लिखो(DEBUG_tcg, "TCGBIOS: TPM malfunctioning (line %d).\n", __LINE__);

    tpm_set_failure();
पूर्ण


/****************************************************************
 * BIOS पूर्णांकerface
 ****************************************************************/

u8 TPM_पूर्णांकerface_shutकरोwn VARLOW;

अटल अंतरभूत व्योम *input_buf32(काष्ठा bregs *regs)
अणु
    वापस MAKE_FLATPTR(regs->es, regs->di);
पूर्ण

अटल अंतरभूत व्योम *output_buf32(काष्ठा bregs *regs)
अणु
    वापस MAKE_FLATPTR(regs->ds, regs->si);
पूर्ण

अटल u32
hash_log_extend(काष्ठा pcpes *pcpes, स्थिर व्योम *hashdata, u32 hashdata_length
                , व्योम *event, पूर्णांक extend)
अणु
    अगर (pcpes->pcrindex >= 24)
        वापस TCG_INVALID_INPUT_PARA;
    अगर (hashdata)
        sha1(hashdata, hashdata_length, pcpes->digest);

    काष्ठा tpm_log_entry le = अणु
        .hdr.pcrindex = pcpes->pcrindex,
        .hdr.eventtype = pcpes->eventtype,
    पूर्ण;
    पूर्णांक digest_len = tpm12_build_digest_direct(&le, pcpes->digest);
    अगर (digest_len < 0)
        वापस TCG_GENERAL_ERROR;
    अगर (extend) अणु
        पूर्णांक ret = tpm_extend(&le, digest_len);
        अगर (ret)
            वापस TCG_TCG_COMMAND_ERROR;
    पूर्ण
    tpm12_build_digest_direct(&le, pcpes->digest);
    पूर्णांक ret = tpm_log_event(&le.hdr, digest_len
                            , pcpes->event, pcpes->eventdatasize);
    अगर (ret)
        वापस TCG_PC_LOGOVERFLOW;
    वापस 0;
पूर्ण

अटल u32
hash_log_extend_event_पूर्णांक(स्थिर काष्ठा hleei_लघु *hleei_s,
                          काष्ठा hleeo *hleeo)
अणु
    u32 rc = 0;
    काष्ठा hleei_दीर्घ *hleei_l = (काष्ठा hleei_दीर्घ *)hleei_s;
    स्थिर व्योम *logdataptr;
    u32 logdatalen;
    काष्ठा pcpes *pcpes;
    u32 pcrindex;

    /* लघु or दीर्घ version? */
    चयन (hleei_s->ipblength) अणु
    हाल माप(काष्ठा hleei_लघु):
        /* लघु */
        logdataptr = hleei_s->logdataptr;
        logdatalen = hleei_s->logdatalen;
        pcrindex = hleei_s->pcrindex;
    अवरोध;

    हाल माप(काष्ठा hleei_दीर्घ):
        /* दीर्घ */
        logdataptr = hleei_l->logdataptr;
        logdatalen = hleei_l->logdatalen;
        pcrindex = hleei_l->pcrindex;
    अवरोध;

    शेष:
        /* bad input block */
        rc = TCG_INVALID_INPUT_PARA;
        जाओ err_निकास;
    पूर्ण

    pcpes = (काष्ठा pcpes *)logdataptr;

    अगर (pcpes->pcrindex != pcrindex
        || logdatalen != माप(*pcpes) + pcpes->eventdatasize) अणु
        rc = TCG_INVALID_INPUT_PARA;
        जाओ err_निकास;
    पूर्ण
    rc = hash_log_extend(pcpes, hleei_s->hashdataptr, hleei_s->hashdatalen
                         , pcpes->event, 1);
    अगर (rc)
        जाओ err_निकास;

    hleeo->opblength = माप(काष्ठा hleeo);
    hleeo->reserved  = 0;
    hleeo->eventnumber = tpm_state.entry_count;
    स_नकल(hleeo->digest, pcpes->digest, माप(hleeo->digest));

err_निकास:
    अगर (rc != 0) अणु
        hleeo->opblength = 4;
        hleeo->reserved  = 0;
    पूर्ण

    वापस rc;
पूर्ण

अटल u32
pass_through_to_tpm_पूर्णांक(काष्ठा pttti *pttti, काष्ठा pttto *pttto)
अणु
    u32 rc = 0;
    काष्ठा tpm_req_header *trh = (व्योम*)pttti->tpmopin;

    अगर (pttti->ipblength < माप(काष्ठा pttti) + माप(*trh)
        || pttti->ipblength != माप(काष्ठा pttti) + be32_to_cpu(trh->totlen)
        || pttti->opblength < माप(काष्ठा pttto)) अणु
        rc = TCG_INVALID_INPUT_PARA;
        जाओ err_निकास;
    पूर्ण

    u16 tag = be16_to_cpu(trh->tag);

    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        अगर (tag != TPM_TAG_RQU_CMD && tag != TPM_TAG_RQU_AUTH1_CMD
            && tag != TPM_TAG_RQU_AUTH2_CMD) अणु
            rc = TCG_INVALID_INPUT_PARA;
            जाओ err_निकास;
        पूर्ण
        अवरोध;
    हाल TPM_VERSION_2:
        अगर (tag != TPM2_ST_NO_SESSIONS && tag != TPM2_ST_SESSIONS) अणु
            rc = TCG_INVALID_INPUT_PARA;
            जाओ err_निकास;
        पूर्ण
    पूर्ण

    u32 resbuflen = pttti->opblength - दुरत्व(काष्ठा pttto, tpmopout);
    पूर्णांक ret = tpmhw_transmit(0, trh, pttto->tpmopout, &resbuflen,
                             TPM_DURATION_TYPE_LONG /* worst हाल */);
    अगर (ret) अणु
        rc = TCG_FATAL_COM_ERROR;
        जाओ err_निकास;
    पूर्ण

    pttto->opblength = दुरत्व(काष्ठा pttto, tpmopout) + resbuflen;
    pttto->reserved  = 0;

err_निकास:
    अगर (rc != 0) अणु
        pttto->opblength = 4;
        pttto->reserved = 0;
    पूर्ण

    वापस rc;
पूर्ण

अटल u32
shutकरोwn_preboot_पूर्णांकerface(व्योम)
अणु
    TPM_पूर्णांकerface_shutकरोwn = 1;
    वापस 0;
पूर्ण

अटल u32
hash_log_event_पूर्णांक(स्थिर काष्ठा hlei *hlei, काष्ठा hleo *hleo)
अणु
    u32 rc = 0;
    u16 size;
    काष्ठा pcpes *pcpes;

    size = hlei->ipblength;
    अगर (size != माप(*hlei)) अणु
        rc = TCG_INVALID_INPUT_PARA;
        जाओ err_निकास;
    पूर्ण

    pcpes = (काष्ठा pcpes *)hlei->logdataptr;

    अगर (pcpes->pcrindex != hlei->pcrindex
        || pcpes->eventtype != hlei->logeventtype
        || hlei->logdatalen != माप(*pcpes) + pcpes->eventdatasize) अणु
        rc = TCG_INVALID_INPUT_PARA;
        जाओ err_निकास;
    पूर्ण
    rc = hash_log_extend(pcpes, hlei->hashdataptr, hlei->hashdatalen
                         , pcpes->event, 0);
    अगर (rc)
        जाओ err_निकास;

    /* updating the log was fine */
    hleo->opblength = माप(काष्ठा hleo);
    hleo->reserved  = 0;
    hleo->eventnumber = tpm_state.entry_count;

err_निकास:
    अगर (rc != 0) अणु
        hleo->opblength = 2;
        hleo->reserved = 0;
    पूर्ण

    वापस rc;
पूर्ण

अटल u32
hash_all_पूर्णांक(स्थिर काष्ठा hai *hai, u8 *hash)
अणु
    अगर (hai->ipblength != माप(काष्ठा hai) ||
        hai->hashdataptr == 0 ||
        hai->hashdatalen == 0 ||
        hai->algorithmid != TPM_ALG_SHA)
        वापस TCG_INVALID_INPUT_PARA;

    sha1((स्थिर u8 *)hai->hashdataptr, hai->hashdatalen, hash);
    वापस 0;
पूर्ण

अटल u32
tss_पूर्णांक(काष्ठा ti *ti, काष्ठा to *to)
अणु
    to->opblength = माप(काष्ठा to);
    to->reserved  = 0;

    वापस TCG_PC_UNSUPPORTED;
पूर्ण

अटल u32
compact_hash_log_extend_event_पूर्णांक(u8 *buffer,
                                  u32 info,
                                  u32 length,
                                  u32 pcrindex,
                                  u32 *edx_ptr)
अणु
    काष्ठा pcpes pcpes = अणु
        .pcrindex      = pcrindex,
        .eventtype     = EV_COMPACT_HASH,
        .eventdatasize = माप(info),
    पूर्ण;
    u32 rc = hash_log_extend(&pcpes, buffer, length, &info, 1);
    अगर (rc)
        वापस rc;

    *edx_ptr = tpm_state.entry_count;
    वापस 0;
पूर्ण

व्योम VISIBLE32FLAT
tpm_पूर्णांकerrupt_handler32(काष्ठा bregs *regs)
अणु
    अगर (!CONFIG_TCGBIOS)
        वापस;

    set_cf(regs, 0);

    अगर (TPM_पूर्णांकerface_shutकरोwn && regs->al) अणु
        regs->eax = TCG_INTERFACE_SHUTDOWN;
        वापस;
    पूर्ण

    चयन ((क्रमागत irq_ids)regs->al) अणु
    हाल TCG_StatusCheck:
        अगर (!tpmhw_is_present()) अणु
            /* no TPM available */
            regs->eax = TCG_PC_TPM_NOT_PRESENT;
        पूर्ण अन्यथा अणु
            regs->eax = 0;
            regs->ebx = TCG_MAGIC;
            regs->ch = TCG_VERSION_MAJOR;
            regs->cl = TCG_VERSION_MINOR;
            regs->edx = 0x0;
            regs->esi = (u32)tpm_state.log_area_start_address;
            regs->edi = (u32)tpm_state.log_area_last_entry;
        पूर्ण
        अवरोध;

    हाल TCG_HashLogExtendEvent:
        regs->eax =
            hash_log_extend_event_पूर्णांक(
                  (काष्ठा hleei_लघु *)input_buf32(regs),
                  (काष्ठा hleeo *)output_buf32(regs));
        अवरोध;

    हाल TCG_PassThroughToTPM:
        regs->eax =
            pass_through_to_tpm_पूर्णांक((काष्ठा pttti *)input_buf32(regs),
                                    (काष्ठा pttto *)output_buf32(regs));
        अवरोध;

    हाल TCG_ShutकरोwnPreBootInterface:
        regs->eax = shutकरोwn_preboot_पूर्णांकerface();
        अवरोध;

    हाल TCG_HashLogEvent:
        regs->eax = hash_log_event_पूर्णांक((काष्ठा hlei*)input_buf32(regs),
                                       (काष्ठा hleo*)output_buf32(regs));
        अवरोध;

    हाल TCG_HashAll:
        regs->eax =
            hash_all_पूर्णांक((काष्ठा hai*)input_buf32(regs),
                          (u8 *)output_buf32(regs));
        अवरोध;

    हाल TCG_TSS:
        regs->eax = tss_पूर्णांक((काष्ठा ti*)input_buf32(regs),
                            (काष्ठा to*)output_buf32(regs));
        अवरोध;

    हाल TCG_CompactHashLogExtendEvent:
        regs->eax =
          compact_hash_log_extend_event_पूर्णांक((u8 *)input_buf32(regs),
                                            regs->esi,
                                            regs->ecx,
                                            regs->edx,
                                            &regs->edx);
        अवरोध;

    शेष:
        set_cf(regs, 1);
    पूर्ण

    वापस;
पूर्ण


/****************************************************************
 * TPM Configuration Menu
 ****************************************************************/

प्रकार u8 tpm_ppi_code;

अटल पूर्णांक
tpm12_पढ़ो_has_owner(पूर्णांक *has_owner)
अणु
    काष्ठा tpm_res_अ_लोap_ownerauth oauth;
    पूर्णांक ret = tpm12_get_capability(TPM_CAP_PROPERTY, TPM_CAP_PROP_OWNER
                                   , &oauth.hdr, माप(oauth));
    अगर (ret)
        वापस -1;

    *has_owner = oauth.flag;

    वापस 0;
पूर्ण

अटल पूर्णांक
tpm12_enable_tpm(पूर्णांक enable, पूर्णांक verbose)
अणु
    काष्ठा tpm_permanent_flags pf;
    पूर्णांक ret = tpm12_पढ़ो_permanent_flags((अक्षर *)&pf, माप(pf));
    अगर (ret)
        वापस -1;

    अगर (pf.flags[PERM_FLAG_IDX_DISABLE] && !enable)
        वापस 0;

    ret = tpm_simple_cmd(0, enable ? TPM_ORD_PhysicalEnable
                                   : TPM_ORD_PhysicalDisable,
                         0, 0, TPM_DURATION_TYPE_SHORT);
    अगर (ret) अणु
        अगर (enable)
            dम_लिखो(DEBUG_tcg, "TCGBIOS: Enabling the TPM failed.\n");
        अन्यथा
            dम_लिखो(DEBUG_tcg, "TCGBIOS: Disabling the TPM failed.\n");
    पूर्ण
    वापस ret;
पूर्ण

अटल पूर्णांक
tpm12_activate_tpm(पूर्णांक activate, पूर्णांक allow_reset, पूर्णांक verbose)
अणु
    काष्ठा tpm_permanent_flags pf;
    पूर्णांक ret = tpm12_पढ़ो_permanent_flags((अक्षर *)&pf, माप(pf));
    अगर (ret)
        वापस -1;

    अगर (pf.flags[PERM_FLAG_IDX_DEACTIVATED] && !activate)
        वापस 0;

    अगर (pf.flags[PERM_FLAG_IDX_DISABLE])
        वापस 0;

    ret = tpm_simple_cmd(0, TPM_ORD_PhysicalSetDeactivated,
                         1, activate ? 0x00 : 0x01, TPM_DURATION_TYPE_SHORT);
    अगर (ret)
        वापस ret;

    अगर (activate && allow_reset) अणु
        अगर (verbose) अणु
            म_लिखो("Requiring a reboot to activate the TPM.\n");

            msleep(2000);
        पूर्ण
        reset();
    पूर्ण

    वापस 0;
पूर्ण

अटल पूर्णांक
tpm12_enable_activate(पूर्णांक allow_reset, पूर्णांक verbose)
अणु
    पूर्णांक ret = tpm12_enable_tpm(1, verbose);
    अगर (ret)
        वापस ret;

    वापस tpm12_activate_tpm(1, allow_reset, verbose);
पूर्ण

अटल पूर्णांक
tpm12_क्रमce_clear(पूर्णांक enable_activate_beक्रमe, पूर्णांक enable_activate_after,
                  पूर्णांक verbose)
अणु
    पूर्णांक has_owner;
    पूर्णांक ret = tpm12_पढ़ो_has_owner(&has_owner);
    अगर (ret)
        वापस -1;
    अगर (!has_owner) अणु
        अगर (verbose)
            म_लिखो("TPM does not have an owner.\n");
        वापस 0;
    पूर्ण

    अगर (enable_activate_beक्रमe) अणु
        ret = tpm12_enable_activate(0, verbose);
        अगर (ret) अणु
            dम_लिखो(DEBUG_tcg,
                    "TCGBIOS: Enabling/activating the TPM failed.\n");
            वापस ret;
        पूर्ण
    पूर्ण

    ret = tpm_simple_cmd(0, TPM_ORD_ForceClear,
                         0, 0, TPM_DURATION_TYPE_SHORT);
    अगर (ret)
        वापस ret;

    अगर (!enable_activate_after) अणु
        अगर (verbose)
            म_लिखो("Owner successfully cleared.\n"
                   "You will need to enable/activate the TPM again.\n\n");
        वापस 0;
    पूर्ण

    वापस tpm12_enable_activate(1, verbose);
पूर्ण

अटल पूर्णांक
tpm12_set_owner_install(पूर्णांक allow, पूर्णांक verbose)
अणु
    पूर्णांक has_owner;
    पूर्णांक ret = tpm12_पढ़ो_has_owner(&has_owner);
    अगर (ret)
        वापस -1;
    अगर (has_owner) अणु
        अगर (verbose)
            म_लिखो("Must first remove owner.\n");
        वापस 0;
    पूर्ण

    काष्ठा tpm_permanent_flags pf;
    ret = tpm12_पढ़ो_permanent_flags((अक्षर *)&pf, माप(pf));
    अगर (ret)
        वापस -1;

    अगर (pf.flags[PERM_FLAG_IDX_DISABLE]) अणु
        अगर (verbose)
            म_लिखो("TPM must first be enable.\n");
        वापस 0;
    पूर्ण

    ret = tpm_simple_cmd(0, TPM_ORD_SetOwnerInstall,
                         1, allow ? 0x01 : 0x00, TPM_DURATION_TYPE_SHORT);
    अगर (ret)
        वापस ret;

    अगर (verbose)
        म_लिखो("Installation of owner %s.\n", allow ? "enabled" : "disabled");

    वापस 0;
पूर्ण

अटल पूर्णांक
tpm12_process_cfg(tpm_ppi_code msgCode, पूर्णांक verbose)
अणु
    पूर्णांक ret = 0;

    चयन (msgCode) अणु
        हाल TPM_PPI_OP_NOOP: /* no-op */
            अवरोध;

        हाल TPM_PPI_OP_ENABLE:
            ret = tpm12_enable_tpm(1, verbose);
            अवरोध;

        हाल TPM_PPI_OP_DISABLE:
            ret = tpm12_enable_tpm(0, verbose);
            अवरोध;

        हाल TPM_PPI_OP_ACTIVATE:
            ret = tpm12_activate_tpm(1, 1, verbose);
            अवरोध;

        हाल TPM_PPI_OP_DEACTIVATE:
            ret = tpm12_activate_tpm(0, 1, verbose);
            अवरोध;

        हाल TPM_PPI_OP_CLEAR:
            ret = tpm12_क्रमce_clear(1, 0, verbose);
            अवरोध;

        हाल TPM_PPI_OP_SET_OWNERINSTALL_TRUE:
            ret = tpm12_set_owner_install(1, verbose);
            अवरोध;

        हाल TPM_PPI_OP_SET_OWNERINSTALL_FALSE:
            ret = tpm12_set_owner_install(0, verbose);
            अवरोध;

        शेष:
            अवरोध;
    पूर्ण

    अगर (ret)
        म_लिखो("Op %d: An error occurred: 0x%x\n", msgCode, ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_clearcontrol(u8 disable, पूर्णांक verbose)
अणु
    काष्ठा tpm2_req_clearcontrol trc = अणु
        .hdr.tag     = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.totlen  = cpu_to_be32(माप(trc)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_ClearControl),
        .authhandle = cpu_to_be32(TPM2_RH_PLATFORM),
        .authblocksize = cpu_to_be32(माप(trc.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
        .disable = disable,
    पूर्ण;
    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &trc.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_SHORT);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        ret = -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_ClearControl = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_clear(व्योम)
अणु
    काष्ठा tpm2_req_clear trq = अणु
        .hdr.tag     = cpu_to_be16(TPM2_ST_SESSIONS),
        .hdr.totlen  = cpu_to_be32(माप(trq)),
        .hdr.ordinal = cpu_to_be32(TPM2_CC_Clear),
        .authhandle = cpu_to_be32(TPM2_RH_PLATFORM),
        .authblocksize = cpu_to_be32(माप(trq.authblock)),
        .authblock = अणु
            .handle = cpu_to_be32(TPM2_RS_PW),
            .noncesize = cpu_to_be16(0),
            .contsession = TPM2_YES,
            .pwdsize = cpu_to_be16(0),
        पूर्ण,
    पूर्ण;
    काष्ठा tpm_rsp_header rsp;
    u32 resp_length = माप(rsp);
    पूर्णांक ret = tpmhw_transmit(0, &trq.hdr, &rsp, &resp_length,
                             TPM_DURATION_TYPE_MEDIUM);
    अगर (ret || resp_length != माप(rsp) || rsp.errcode)
        ret = -1;

    dम_लिखो(DEBUG_tcg, "TCGBIOS: Return value from sending TPM2_CC_Clear = 0x%08x\n",
            ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm20_process_cfg(tpm_ppi_code msgCode, पूर्णांक verbose)
अणु
    पूर्णांक ret = 0;

    चयन (msgCode) अणु
        हाल TPM_PPI_OP_NOOP: /* no-op */
            अवरोध;

        हाल TPM_PPI_OP_CLEAR:
            ret = tpm20_clearcontrol(0, verbose);
            अगर (!ret)
                 ret = tpm20_clear();
            अवरोध;
    पूर्ण

    अगर (ret)
        म_लिखो("Op %d: An error occurred: 0x%x\n", msgCode, ret);

    वापस ret;
पूर्ण

अटल पूर्णांक
tpm12_get_tpm_state(व्योम)
अणु
    पूर्णांक state = 0;
    काष्ठा tpm_permanent_flags pf;
    पूर्णांक has_owner;

    अगर (tpm12_पढ़ो_permanent_flags((अक्षर *)&pf, माप(pf)) ||
        tpm12_पढ़ो_has_owner(&has_owner))
        वापस ~0;

    अगर (!pf.flags[PERM_FLAG_IDX_DISABLE])
        state |= TPM_STATE_ENABLED;

    अगर (!pf.flags[PERM_FLAG_IDX_DEACTIVATED])
        state |= TPM_STATE_ACTIVE;

    अगर (has_owner) अणु
        state |= TPM_STATE_OWNED;
    पूर्ण अन्यथा अणु
        अगर (pf.flags[PERM_FLAG_IDX_OWNERSHIP])
            state |= TPM_STATE_OWNERINSTALL;
    पूर्ण

    वापस state;
पूर्ण

अटल व्योम
tpm12_show_tpm_menu(पूर्णांक state, पूर्णांक next_scancodes[7])
अणु
    पूर्णांक i = 0;

    म_लिखो("\nThe current state of the TPM is:\n");

    अगर (state & TPM_STATE_ENABLED)
        म_लिखो("  Enabled");
    अन्यथा
        म_लिखो("  Disabled");

    अगर (state & TPM_STATE_ACTIVE)
        म_लिखो(" and active\n");
    अन्यथा
        म_लिखो(" and deactivated\n");

    अगर (state & TPM_STATE_OWNED)
        म_लिखो("  Ownership has been taken\n");
    अन्यथा अणु
        म_लिखो("  Ownership has not been taken\n");
        अगर (state & TPM_STATE_OWNERINSTALL)
            म_लिखो("  A user can take ownership of the TPM\n");
        अन्यथा
            म_लिखो("  Taking ownership of the TPM has been disabled\n");
    पूर्ण

    अगर ((state & (TPM_STATE_ENABLED | TPM_STATE_ACTIVE)) !=
        (TPM_STATE_ENABLED | TPM_STATE_ACTIVE)) अणु
        म_लिखो("\nNote: To make use of all functionality, the TPM must be "
               "enabled and active.\n");
    पूर्ण

    म_लिखो("\nAvailable options are:\n");
    अगर (state & TPM_STATE_ENABLED) अणु
        म_लिखो(" d. Disable the TPM\n");
        next_scancodes[i++] = 32;

        अगर (state & TPM_STATE_ACTIVE) अणु
            म_लिखो(" v. Deactivate the TPM\n");
            next_scancodes[i++] = 47;

            अगर (state & TPM_STATE_OWNERINSTALL) अणु
                म_लिखो(" p. Prevent installation of an owner\n");
                next_scancodes[i++] = 25;
            पूर्ण अन्यथा अणु
                म_लिखो(" s. Allow installation of an owner\n");
                next_scancodes[i++] = 31;
            पूर्ण
        पूर्ण अन्यथा अणु
            म_लिखो(" a. Activate the TPM\n");
            next_scancodes[i++] = 30;
        पूर्ण

    पूर्ण अन्यथा अणु
        म_लिखो(" e. Enable the TPM\n");
        next_scancodes[i++] = 18;
    पूर्ण

    अगर (state & TPM_STATE_OWNED) अणु
        म_लिखो(" c. Clear ownership\n");
        next_scancodes[i++] = 46;
    पूर्ण

    next_scancodes[i++] = 0;
पूर्ण

अटल व्योम
tpm12_menu(व्योम)
अणु
    पूर्णांक scancode, next_scancodes[7];
    tpm_ppi_code msgCode;
    पूर्णांक state = 0, i;
    पूर्णांक रुकोkey;

    म_लिखो("The Trusted Platform Module (TPM) is a hardware device in "
           "this machine.\n"
           "It can help verify the integrity of system software.\n\n");

    क्रम (;;) अणु
        अगर ((state = tpm12_get_tpm_state()) != ~0) अणु
            tpm12_show_tpm_menu(state, next_scancodes);
        पूर्ण अन्यथा अणु
            म_लिखो("TPM is not working correctly.\n");
            वापस;
        पूर्ण

        म_लिखो("\nIf no change is desired or if this menu was reached by "
               "mistake, press ESC to\n"
               "reboot the machine.\n");

        msgCode = TPM_PPI_OP_NOOP;

        रुकोkey = 1;

        जबतक (रुकोkey) अणु
            जबतक ((scancode = get_keystroke(1000)) == ~0)
                ;

            चयन (scancode) अणु
            हाल 1:
                // ESC
                reset();
                अवरोध;
            हाल 18: /* e. enable */
                msgCode = TPM_PPI_OP_ENABLE;
                अवरोध;
            हाल 32: /* d. disable */
                msgCode = TPM_PPI_OP_DISABLE;
                अवरोध;
            हाल 30: /* a. activate */
                msgCode = TPM_PPI_OP_ACTIVATE;
                अवरोध;
            हाल 47: /* v. deactivate */
                msgCode = TPM_PPI_OP_DEACTIVATE;
                अवरोध;
            हाल 46: /* c. clear owner */
                msgCode = TPM_PPI_OP_CLEAR;
                अवरोध;
            हाल 25: /* p. prevent ownerinstall */
                msgCode = TPM_PPI_OP_SET_OWNERINSTALL_FALSE;
                अवरोध;
            हाल 31: /* s. allow ownerinstall */
                msgCode = TPM_PPI_OP_SET_OWNERINSTALL_TRUE;
                अवरोध;
            शेष:
                जारी;
            पूर्ण

            /*
             * Using the next_scancodes array, check whether the
             * pressed key is currently a valid option.
             */
            क्रम (i = 0; i < माप(next_scancodes); i++) अणु
                अगर (next_scancodes[i] == 0)
                    अवरोध;

                अगर (next_scancodes[i] == scancode) अणु
                    tpm12_process_cfg(msgCode, 1);
                    रुकोkey = 0;
                    अवरोध;
                पूर्ण
            पूर्ण
        पूर्ण
    पूर्ण
पूर्ण

अटल पूर्णांक
tpm20_menu_change_active_pcrbanks(व्योम)
अणु
    u8 active_banks, suppt_banks;

    tpm20_get_suppt_pcrbanks(&suppt_banks, &active_banks);

    u8 activate_banks = active_banks;

    जबतक (1) अणु
        u8 hashalg_flag = TPM2_ALG_SHA1_FLAG;
        u8 i = 0;

        म_लिखो("\nToggle active PCR banks by pressing number key\n\n");

        जबतक (hashalg_flag) अणु
            u8 flag = hashalg_flag & suppt_banks;
            स्थिर अक्षर *hashname = tpm20_hashalg_flag_to_name(flag);

            i++;
            अगर (hashname) अणु
                म_लिखो("  %d: %s", i, hashname);
                अगर (activate_banks & hashalg_flag)
                    म_लिखो(" (enabled)");
                म_लिखो("\n");
            पूर्ण

            hashalg_flag <<= 1;
        पूर्ण
        म_लिखो("\n"
               "ESC: return to previous menu without changes\n");
        अगर (activate_banks)
            म_लिखो("A  : activate selection\n");

        u8 flagnum;
        पूर्णांक show = 0;
        जबतक (!show) अणु
            पूर्णांक scancode = get_keystroke(1000);

            चयन (scancode) अणु
            हाल ~0:
                जारी;
            हाल 1: /* ESC */
                म_लिखो("\n");
                वापस -1;
            हाल 2 ... 6: /* keys 1 .. 5 */
                flagnum = scancode - 1;
                अगर (flagnum > i)
                    जारी;
                अगर (suppt_banks & (1 << (flagnum - 1))) अणु
                    activate_banks ^= 1 << (flagnum - 1);
                    show = 1;
                पूर्ण
                अवरोध;
            हाल 30: /* a */
                अगर (activate_banks)
                    tpm20_activate_pcrbanks(activate_banks);
            पूर्ण
        पूर्ण
    पूर्ण
पूर्ण

अटल व्योम
tpm20_menu(व्योम)
अणु
    पूर्णांक scan_code;
    tpm_ppi_code msgCode;

    क्रम (;;) अणु
        म_लिखो("1. Clear TPM\n");
        म_लिखो("2. Change active PCR banks\n");

        म_लिखो("\nIf no change is desired or if this menu was reached by "
               "mistake, press ESC to\n"
               "reboot the machine.\n");

        msgCode = TPM_PPI_OP_NOOP;

        जबतक ((scan_code = get_keystroke(1000)) == ~0)
            ;

        चयन (scan_code) अणु
        हाल 1:
            // ESC
            reset();
            अवरोध;
        हाल 2:
            msgCode = TPM_PPI_OP_CLEAR;
            अवरोध;
        हाल 3:
            tpm20_menu_change_active_pcrbanks();
            जारी;
        शेष:
            जारी;
        पूर्ण

        tpm20_process_cfg(msgCode, 0);
    पूर्ण
पूर्ण

व्योम
tpm_menu(व्योम)
अणु
    अगर (!CONFIG_TCGBIOS)
        वापस;

    जबतक (get_keystroke(0) >= 0)
        ;
    रुको_thपढ़ोs();

    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        tpm12_menu();
        अवरोध;
    हाल TPM_VERSION_2:
        tpm20_menu();
        अवरोध;
    पूर्ण
पूर्ण

पूर्णांक
tpm_can_show_menu(व्योम)
अणु
    चयन (TPM_version) अणु
    हाल TPM_VERSION_1_2:
        वापस tpm_is_working() && TPM_has_physical_presence;
    हाल TPM_VERSION_2:
        वापस tpm_is_working();
    पूर्ण
    वापस 0;
पूर्ण
